---
layout: post
title: "SOLID"
description: 
headline: 
modified: 2022-01-26
category: webdevelopment
imagefeature: cover3.jpg
tags: [SOLID]
mathjax: 
chart: 
share: true
comments: true
featured: true
disqus:
---

# Record
## 개념
- 


| 두문자 | 약어 | 개념 |
|------|------|:------|
| S	| SRP	| 단일 책임 원칙 (Single responsibility principle) 한 클래스는 하나의 책임만 가져야 한다. |
| O	| OCP	| 개방-폐쇄 원칙 (Open/closed principle) “소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.” |
| L	| LSP	| 리스코프 치환 원칙 (Liskov substitution principle) “프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.” 계약에 의한 설계를 참고하라. |
| I	| ISP	| 인터페이스 분리 원칙 (Interface segregation principle) “특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.”[4] |
| D	| DIP	| 의존관계 역전 원칙 (Dependency inversion principle) 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.”[4] 의존성 주입은 이 원칙을 따르는 방법 중 하나다. |


** 이 원칙들은 애자일 소프트웨어 개발과 적응적 소프트웨어 개발의 전반적 전략의 일부다

## 목차
- [](#)

### 단일 책임 원칙 (Single responsibility principle)
객체 지향 프로그래밍에서 단일 책임 원칙(single responsibility principle)이란 모든 클래스는 하나의 책임만 가지며, 클래스는 그 책임을 완전히 캡슐화해야 함을 일컫는다. 클래스가 제공하는 모든 기능은 이 책임과 주의 깊게 부합해야 한다.

### 개방-폐쇄 원칙 (Open/closed principle)
개방-폐쇄 원칙(OCP, Open-Closed Principle)은 '소프트웨어 개체(클래스, 모듈, 함수 등등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다'는 프로그래밍 원칙이다.<br>

추상클래스 레벨에서 접근하여 구현하여 수정하는 것을 말한다.<br>
소프트웨어 개체는 확장에 대해 열려 있어야하고, 수정에 대해서는 닫혀있어야 한다는 원칙이다.<br>

### 리스코프 치환 원칙 (Liskov substitution principle)
치환성(영어: substitutability)은 객체 지향 프로그래밍 원칙이다. 컴퓨터 프로그램에서 자료형 S가 자료형 T의 하위형이라면 필요한 프로그램의 속성(정확성, 수행하는 업무 등)의 변경 없이 자료형 T의 객체를 자료형 S의 객체로 교체(치환)할 수 있어야 한다는 원칙이다.<br>
상위 타입의 객체를 하위타입의 객체로 치환하더라도 상위 타입을 사용하는 프로그램은 정상적으로 동작해야한다는 원칙이다.

### 인터페이스 분리 원칙 (Interface segregation principle)
인터페이스 분리 원칙은 클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다. 인터페이스 분리 원칙은 큰 덩어리의 인터페이스들을 구체적이고 작은 단위들로 분리시킴으로써 클라이언트들이 꼭 필요한 메서드들만 이용할 수 있게 한다. 이와 같은 작은 단위들을 역할 인터페이스라고도 부른다. 인터페이스 분리 원칙을 통해 시스템의 내부 의존성을 약화시켜 리팩토링, 수정, 재배포를 쉽게 할 수 있다. 인터페이스 분리 원칙은 SOLID 5원칙의 하나이며, GRASP의 밀착 원칙과 비슷하다.

제공하는 기능에 대한 인터페이스에만 종속적이어야 한다.<br>
만약 하나의 객체가 여러 기능을 제공해야 한다면 ( 단일 책임 원칙에 위배 ),이때 클라이언트가 사용할 수 있는 여러 인터페이스로 분리하여 제공하면 클라이언트가 사용하지 않는 기능에 종속적이지 않을 수 있다.<br>
여러 기능이 복합적으로 제공되는데 만약 분리가 할 필요가 있고 사용할때는 나눠서 사용한다고 한다면 인터페이스를 나눠서 사용하는 것이 좋다.<br>
클라이언트가 자신이 이용하지 않는 메서드에 의존하지 않아야 한다는 원칙이다. <br>
큰 덩어리의 인터페이스들을 구체적으로 작은 단위들로 분리시킴으로써 클라이언트가 꼭 필요한 메서드들만 이용할 수 있게 한다.<br>

### 의존관계 역전 원칙 (Dependency inversion principle)
객체 지향 프로그래밍에서 의존관계 역전 원칙은 소프트웨어 모듈들을 분리하는 특정 형식을 지칭한다. 이 원칙을 따르면, 상위 계층(정책 결정)이 하위 계층(세부 사항)에 의존하는 전통적인 의존관계를 반전(역전)시킴으로써 상위 계층이 하위 계층의 구현으로부터 독립되게 할 수 있다. 이 원칙은 다음과 같은 내용을 담고 있다.<br>
    첫째, 상위 모듈은 하위 모듈에 의존해서는 안된다. 상위 모듈과 하위 모듈 모두 추상화에 의존해야 한다.<br>
    둘째, 추상화는 세부 사항에 의존해서는 안된다. 세부사항이 추상화에 의존해야 한다.<br>
이 원칙은 '상위와 하위 객체 모두가 동일한 추상화에 의존해야 한다'는 객체 지향적 설계의 대원칙을 제공한다.<br>


소프트웨어 모듈들을 분리하는 특정 형식을 지칭하는 것을 말한다.<br>
정책을 결정하는 상위 계층이 세부사항인 하위계층에 의존하는 전통적인 의존관계를 반대로 역전 시킴으로써 상위계층이 하위 계층의 구현으로부터 독립되게 할 수 있다.<br>
A가 B에(a -> b) 의존한다고 하면 <br>
업캐스팅, 상위 클래스를 받도록 하면 다양한 하위 클래스를 받아올 수 있음.<br>



## 참조

기본 개념과 연관 주제
- 적응적 소프트웨어 개발
- 애자일 소프트웨어 개발
- 코드 재사용
- 객체 지향 프로그래밍
    - 상속 (객체 지향 프로그래밍)
- 오컴의 면도날

설계와 개발 원칙
- 패키지 원칙
- DRY
- GRASP
- KISS
- YAGNI



- Interceptor와 Filter는 Servlet 단위에서 실행된다. <> 반면 AOP는 메소드 앞에 Proxy패턴의 형태로 실행된다.
- 실행순서를 보면 Filter가 가장 밖에 있고 그안에 Interceptor, 그안에 AOP가 있는 형태이다.
따라서 요청이 들어오면 Filter → Interceptor → AOP → Interceptor → Filter 순으로 거치게 된다.

1. 서버를 실행시켜 서블릿이 올라오는 동안에 init이 실행되고, 그 후 doFilter가 실행된다. 
2. 컨트롤러에 들어가기 전 preHandler가 실행된다
3. 컨트롤러에서 나와 postHandler, after Completion, doFilter 순으로 진행이 된다.
4. 서블릿 종료 시 destroy가 실행된다.


# Filter
말그대로 요청과 응답을 거른뒤 정제하는 역할을 한다.

서블릿 필터는 DispatcherServlet 이전에 실행이 되는데 필터가 동작하도록 지정된 자원의 앞단에서 요청내용을 변경하거나,  여러가지 체크를 수행할 수 있다.

또한 자원의 처리가 끝난 후 응답내용에 대해서도 변경하는 처리를 할 수가 있다. <br>
보통 web.xml에 등록하고, 일반적으로 인코딩 변환 처리, XSS방어 등의 요청에 대한 처리로 사용된다.

[ 실행메서드 ] <br>
ㆍinit() - 필터 인스턴스 초기화 <br>
ㆍdoFilter() - 전/후 처리 <br>
ㆍdestroy() - 필터 인스턴스 종료 <br>

# Interceptor
요청에 대한 작업 전/후로 가로챈다고 보면 된다.

필터는 스프링 컨텍스트 외부에 존재하여 스프링과 무관한 자원에 대해 동작한다.  <br>
하지만 인터셉터는 스프링의 DistpatcherServlet이 컨트롤러를 호출하기 전, 후로 끼어들기 때문에 스프링 컨텍스트(Context, 영역) 내부에서 Controller(Handler)에 관한 요청과 응답에 대해 처리한다.

스프링의 모든 빈 객체에 접근할 수 있다.

인터셉터는 여러 개를 사용할 수 있고 로그인 체크, 권한체크, 프로그램 실행시간 계산작업 로그확인 등의 업무처리

[ 실행메서드 ] <br>
ㆍpreHandler() - 컨트롤러 메서드가 실행되기 전 <br>
ㆍpostHanler() - 컨트롤러 메서드 실행직 후 view페이지 렌더링 되기 전 <br>
ㆍafterCompletion() - view페이지가 렌더링 되고 난 후 <br>

# AOP
OOP를 보완하기 위해 나온 개념 

객체 지향의 프로그래밍을 했을 때 중복을 줄일 수 없는 부분을 줄이기 위해 종단면(관점)에서 바라보고 처리한다.

주로 '로깅', '트랜잭션', '에러 처리'등 비즈니스단의 메서드에서 조금 더 세밀하게 조정하고 싶을 때 사용합니다. <br>
Interceptor나 Filter와는 달리 메소드 전후의 지점에 자유롭게 설정이 가능하다. <br>
Interceptor와 Filter는 주소로 대상을 구분해서 걸러내야하는 반면, AOP는 주소, 파라미터, 애노테이션 등 다양한 방법으로 대상을 지정할 수 있다.

AOP의 Advice와 HandlerInterceptor의 가장 큰 차이는 파라미터의 차이다. <br>
Advice의 경우 JoinPoint나 ProceedingJoinPoint 등을 활용해서 호출한다. <br>
반면 HandlerInterceptor는 Filter와 유사하게 HttpServletRequest, HttpServletResponse를 파라미터로 사용한다.

[ 포인트컷 ] <br>
ㆍ@Before: 대상 메서드의 수행 전 <br>
ㆍ@After: 대상 메서드의 수행 후 <br>
ㆍ@After-returning: 대상 메서드의 정상적인 수행 후 <br>
ㆍ@After-throwing: 예외발생 후 <br>
ㆍ@Around: 대상 메서드의 수행 전/후 <br>